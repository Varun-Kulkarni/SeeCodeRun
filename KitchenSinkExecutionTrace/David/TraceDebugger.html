<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ACE and Esprima in Action!</title>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.3/ace.js" type="text/javascript" charset="utf-8"></script>
<!-- Init Scripts for Execution Trace API !-->
<script src="./scripts/esprima.js" type="text/javascript" charset="utf-8"></script>
<script src="./scripts/escodegen.browser.js" type="text/javascript" charset="utf-8"></script>
<script src="./scripts/estraverse.js" type="text/javascript" charset="utf-8"></script>
<script src="./scripts/esmorph.js" type="text/javascript" charset="utf-8"></script>
<script src="./scripts/executiontrace.js" type="text/javascript" charset="utf-8"></script>
<script src="./scripts/debugger.js" type="text/javascript" charset="utf-8"></script>
<!-- End Scripts for Execution Trace API !-->

<style type="text/css" media="screen">
    #editor { 
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
    }
	
	#info{
		position:absolute;
		background-color: #F55;
		border-radius: 1px;
		top: 20px;
		left: 610px;
		width: 200px;
		z-index: 101;		
	}
	#stacktrace{
		position:absolute;
		background-color: #FF9;
		border-radius: 1px;
		top: 40px;
		left: 610px;
		width: auto;
		bottom: auto;
		z-index: 100;		
	}
	.seecoderun_tooltip {
		background-color: #FFF;
		background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));
		background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));
		border: 1px solid gray;
		border-radius: 1px;
		box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
		color: black;
		max-width: 100%;
		padding: 3px 4px;
		position: absolute;
		z-index: 10;
		-moz-box-sizing: border-box;
		-webkit-box-sizing: border-box;
		box-sizing: border-box;
		cursor: default;
		white-space: pre;
		word-wrap: break-word;
		line-height: normal;
		font-style: normal;
		font-weight: normal;
		letter-spacing: normal;
		pointer-events: none;
		display: none;
	}

	.ace_gutter-cell.seecoderun_gutter_decoration{
        background-color: #FFF;
        border-radius: 20px 0px 0px 20px; 
        box-shadow: 0px 0px 1px 1px red inset;
        background-repeat: no-repeat;
        background-position: 2px center;
    }
</style>
</head>
<body>
<pre id="editor">
//example of TraceViewModel using AceUtils
Array.prototype.swap = function (i, j) {
    var k = this[i]; this[i] = this[j]; this[j] = k;
};

function bubbleSort(list) {
    var items = list.slice(0), swapped = false, p, q;
    for (p = 1; p < items.length; ++p) {
        for (q = 0; q < items.length - p; ++q) {
            if (items[q + 1] < items[q]) {
                items.swap(q, q + 1);
                swapped =true;
            }
        }
        if (!swapped) break;
    }
    return items;
}

var N = 5, data = []; while (N > 0) data.push(N--);
bubbleSort(data);

/*    
let x= 5;
let y = 6;

x = 7;
y = 8;


// other cases
var N = 5, data = [4, 5]; 

while (N > 0) 
    data.push(N--);

var x = { c :  N};
x.c++;
delete x.c;

let c= false, d= [];
var i, n=5;

if(c){
    var x=7;
}else{
    
}

for(let i= 0; i < 5; i++){
    d.push(i);
}
let z = d;
*/
</pre>
<div id="info" >Ready.</div>
<div id="stacktrace" >None</div>
<script>

// requires CSS styles for decorations (.ace_gutter-cell.seecoderun_gutter_decoration) and tooltips (.seecoderun_tooltip)
class AceUtils{
    constructor(){
        //stateless
    }
    // will add the tooltip rendering to a given editor.
    //It will find decorations and add show a tooltip if there row that matches the cursor.
    //The datamodel must contain a "rows" property with an array of rows as indexes.
    //Each row of rows should have a "text" property to be shown.
    // todo: generalize this method with a ViewModel{ view, datamodel} and enum for ace's events
    
    subscribeToEvents(editor, tooltip, gutterDecorationClassName, dataModel){
        let updateTooltip = this.updateTooltip;
        let isPositionInRange = this.isPositionInRange;
        let isRangeInRangeStrict = this.isRangeInRangeStrict; 

        // for tap/ click use guttermousedown
    	editor.on("guttermousemove", function(e){ 
    	    updateTooltip(tooltip, editor.renderer.textToScreenCoordinates(e.getDocumentPosition()));
    		let target = e.domEvent.target; 
    		// is this the element we want? They are Ace cells, "ace_gutter-cell", which have the gutterDecorationClassName CSS style
    		if (target.className.indexOf(gutterDecorationClassName) == -1){ 
    			return;
    		}
    		// is this during user attention?
    		if (!editor.isFocused()){ 
    			return;
    		}
    		// is not the folding icon to the right of the line number?
    		if (e.clientX > target.parentElement.getBoundingClientRect().right - 13){ 
    			return; 
    		}
    		let row = e.getDocumentPosition().row;
    		let text = "";
    		
    		if(dataModel.rows.hasOwnProperty(row)){
                    text = dataModel.rows[row].text; 
    				let pixelPosition = editor.renderer.textToScreenCoordinates(e.getDocumentPosition());
    				pixelPosition.pageY += editor.renderer.lineHeight;
    				updateTooltip(tooltip, pixelPosition, text);
    		}
    		e.stop(); 
    		 
    	});
    	
    	editor.on("mousemove", function (e){
		let position = e.getDocumentPosition(), match;
		if(position){ 
            // todo: Aurelia style
			let result = window.TRACE? window.TRACE.getExecutionTrace() : undefined;
			if(!result){
			    return;
			}
			
			for(let key in result){
			    let data = result[key];
			    
    			 if(data.range && isPositionInRange(position, data.range)){
    			     if(match){
    			         if(isRangeInRangeStrict(data.range, match.range)){
    			             match = data;
    			         }
    			     }else{
    			        match = data;
    			     }
    			 
    			 }
			}
			if(match){
    				let pixelPosition = editor.renderer.textToScreenCoordinates(match.range.start);
    				pixelPosition.pageY += editor.renderer.lineHeight;
    				updateTooltip(tooltip, pixelPosition, match.text +",  values"+ JSON.stringify(match.values));
    		}else{
    				updateTooltip(tooltip, editor.renderer.textToScreenCoordinates(position));
    		}
		}
		});
        
    }
    
    updateTooltip(div, position, text){
			
			div.style.left = position.pageX + 'px';
			div.style.top = position.pageY + 'px';
			if(text){
				div.style.display = "block";
				div.innerText = text;
			}else{
				div.style.display = "none";
				div.innerText = "";
			}
	}
	
	isPositionInRange(position, inRange){
        
        let matchesInOneLine = (
                position.row == inRange.start.row 
                && inRange.start.row  == inRange.end.row
                && position.column >= inRange.start.column
                && position.column <= inRange.end.column
            );
            
        if(matchesInOneLine){
            return true;
        }
            
        let matchesStart = (
                position.row == inRange.start.row 
                && inRange.start.row  < inRange.end.row
                && position.column >= inRange.start.column
            );
           
        if(matchesStart){
            return true;
        }
        
        let matchesEnd = (
                position.row == inRange.end.row
                && inRange.start.row  < inRange.end.row
                && position.column <= inRange.end.column
            );

        return matchesEnd;

    }
    
    isRangeInRange(isRange, inRange){
        return (
                (isRange.start.row >= inRange.start.row && isRange.start.column >= inRange.start.column)
    			 &&
    			(isRange.end.row <= inRange.end.row && isRange.end.column <= inRange.end.column)
    			);
    }
    
    isRangeInRangeStrict(isRange, inRange){
        return (
                (isRange.start.row >= inRange.start.row && isRange.start.column > inRange.start.column)
    			 &&
    			(isRange.end.row <= inRange.end.row && isRange.end.column < inRange.end.column)
    			);
    }
    
    updateGutterDecorations(editor, previousRows, rows, gutterDecorationClassName){
        this.removeGutterDecorations(editor, previousRows, gutterDecorationClassName);
        this.addGutterDecorations(editor, rows, gutterDecorationClassName);
	}
	
	addGutterDecorations(editor, rows, gutterDecorationClassName){
        for (let row in rows) {
            if(rows.hasOwnProperty(row)){
                 editor.getSession().addGutterDecoration(row, gutterDecorationClassName);
            }
        }
	}
		
	removeGutterDecorations(editor, rows, gutterDecorationClassName){
        for(let row in rows){ 
            if(rows.hasOwnProperty(row)){
             editor.getSession().removeGutterDecoration(row, gutterDecorationClassName);
            }
        }
	}
	
    
    getDefaultGutterRenderer(){
        return {
            getWidth: function(session, lastLineNumber, config) {
                return lastLineNumber.toString().length * config.characterWidth;
            },
            getText: function(session, row) {
                return row + 1;
            }
        };
    }  
    
    
    
    /**
     * setTraceGutterRenderer
     * parameters: 
     *              @editor, 
     * description: 
     * pre: editor is defined
     * post: 
     **/
    setTraceGutterRenderer(editor, traceGutterData){
        
        let session = editor.getSession(); // maybe attach the gutterdata to the session?
        let traceGutterRenderer =  {
            getWidth: function(session, lastLineNumber, config) {
                let format = "";
                if(traceGutterData.maxCount > 0){
                    format = "[] ";// adds the brackets and space chars 
                }
                
                return (format.length + traceGutterData.maxCount.toString().length + lastLineNumber.toString().length )* config.characterWidth;
            },
            getText: function(session, row) {
                if(traceGutterData.rows.hasOwnProperty(row)){
                    let count = traceGutterData.rows[row].count; // "never" 0
                    return "["+ count +"] "+ (row + 1);
                }else{
                    return row + 1;
                }
            }
        };
        session.gutterRenderer = traceGutterRenderer;
    }
    
// If more gutter customization is needed. modify this is more than text is needed. Taken from Ace's source code [gutter.js]    
// usage: editor.on("afterRender", updateTraceAnnotations(editor)) // requires DOM access [Aurelia: call within attached()]
    customUpdateGutter(editor, traceGutterRenderer) {
        let dom = document;
        let gutter = editor.renderer.$gutterLayer;
        session.gutterRenderer = traceGutterRenderer;
        let config = editor.renderer.layerConfig;
        let session = editor.getSession();
        let firstRow = config.firstRow;
        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
            session.getLength() - 1);
        var fold = session.getNextFoldLine(firstRow);
        var foldStart = fold ? fold.start.row : Infinity;
        var foldWidgets = gutter.$showFoldWidgets && session.foldWidgets;
        var breakpoints = session.$breakpoints;
        var decorations = session.$decorations;
        var firstLineNumber = session.$firstLineNumber;
        var lastLineNumber = 0;
        
        var gutterRenderer = session.gutterRenderer || gutter.$renderer;

        var cell = null;
        var index = -1;
        var row = firstRow;
        while (true) {
            if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
                while (gutter.$cells.length > index + 1) {
                    cell = gutter.$cells.pop();
                    gutter.element.removeChild(cell.element);
                }
                break;
            }

            cell = gutter.$cells[++index];
            if (!cell) {
                cell = {element: null, textNode: null, foldWidget: null};
                cell.element = dom.createElement("div");
                cell.textNode = document.createTextNode('');
                cell.element.appendChild(cell.textNode);
                gutter.element.appendChild(cell.element);
                gutter.$cells[index] = cell;
            }

            var className = "ace_gutter-cell ";
            if (breakpoints[row])
                className += breakpoints[row];
            if (decorations[row])
                className += decorations[row];
            if (gutter.$annotations[row])
                className += gutter.$annotations[row].className;
            if (cell.element.className != className)
                cell.element.className = className;

            var height = session.getRowLength(row) * config.lineHeight + "px";
            if (height != cell.element.style.height)
                cell.element.style.height = height;

            if (foldWidgets) {
                var c = foldWidgets[row];
                // check if cached value is invalidated and we need to recompute
                if (c == null)
                    c = foldWidgets[row] = session.getFoldWidget(row);
            }

            if (c) {
                if (!cell.foldWidget) {
                    cell.foldWidget = dom.createElement("span");
                    cell.element.appendChild(cell.foldWidget);
                }
                var className = "ace_fold-widget ace_" + c;
                if (c == "start" && row == foldStart && row < fold.end.row)
                    className += " ace_closed";
                else
                    className += " ace_open";
                if (cell.foldWidget.className != className)
                    cell.foldWidget.className = className;

                var height = config.lineHeight + "px";
                if (cell.foldWidget.style.height != height)
                    cell.foldWidget.style.height = height;
            } else {
                if (cell.foldWidget) {
                    cell.element.removeChild(cell.foldWidget);
                    cell.foldWidget = null;
                }
            }
            
            var text = lastLineNumber = gutterRenderer
                ? gutterRenderer.getText(session, row)
                : row + firstLineNumber;
            if (text != cell.textNode.data)
                cell.textNode.data = text;

            row++;
        }
         gutter.element.style.height = config.minHeight + "px";

        if (gutter.$fixedWidth || session.$useWrapMode)
            lastLineNumber = session.getLength() + firstLineNumber;

        var gutterWidth = gutterRenderer 
            ? gutterRenderer.getWidth(session, lastLineNumber, config)
            : lastLineNumber.toString().length * config.characterWidth;
        
        var padding = gutter.$padding || gutter.$computePadding();
        gutterWidth += padding.left + padding.right;
        if (gutterWidth !== gutter.gutterWidth && !isNaN(gutterWidth)) {
            gutter.gutterWidth = gutterWidth;
            gutter.element.style.width = Math.ceil(gutter.gutterWidth) + "px";
            gutter._emit("changeGutterWidth", gutterWidth);
        }
    }
    
}

class TraceViewController{
    // uses AceUtils to render the view based on the editor events and state
    // The view is a tooltip that is binded to the editor
    
}

class TraceViewModel {
    constructor(aceEditor, tooltipElement, gutterDecorationCSSClassName){
        this.editor= aceEditor;
        this.tooltip = tooltipElement;
        this.gutterDecorationClassName = gutterDecorationCSSClassName;
        this.aceUtils = undefined;
        this.traceGutterData = {  maxCount : 0, rows : []  }; // contains custom data to be shown in the gutter cell text
        // remove in Aurelia
        this.attached();
    }
    
    setUpEditor(editor){
        editor.setTheme("ace/theme/monokai");
        editor.getSession().setMode("ace/mode/javascript");
    	editor.renderer.setShowGutter(true);
    //	editor.session.setOption("useWorker", false);
    }
    
    attached(){
        this.resetTraceGutterData();
        let editor = this.editor;
        let tooltip = this.tooltip;
        let traceGutterData =  this.traceGutterData;
        let gutterDecorationClassName = this.gutterDecorationClassName;
        
        this.setUpEditor(editor);
    	let aceUtils = new AceUtils();
    	aceUtils.setTraceGutterRenderer(editor, traceGutterData);
    	
    	aceUtils.subscribeToEvents(editor, tooltip, gutterDecorationClassName, traceGutterData);
        
    	this.aceUtils = aceUtils;
    }
    
    onTraceChanged(trace){
            let previousRows = this.traceGutterData.rows;
            this.updateTraceGutterData(trace);
            let editor = this.editor;
            let traceGutterData = this.traceGutterData;
            let gutterDecorationClassName = this.gutterDecorationClassName;
            this.aceUtils.updateGutterDecorations(editor, previousRows, traceGutterData.rows, gutterDecorationClassName);
    }
    
    // use only after execution trace ends
    updateTraceGutterData(trace){
        let localTraceGutterData = this.extractTraceGutterData(trace);
        this.traceGutterData.maxCount = localTraceGutterData.maxCount;
        this.traceGutterData.rows = localTraceGutterData.rows;
    }
    
    resetTraceGutterData(){
        if(!this.traceGutterData){
            this.traceGutterData = {  maxCount : 0, rows : []  };
            return;
        }
        this.traceGutterData.maxCount = 0;
        this.traceGutterData.rows = [];
    }
    
    extractTraceGutterData(trace){
		    let result = {  maxCount : 0, rows : []  };
    
            for (let i = 0; i < trace.length; i ++) {
                let entry = trace[i];
    			let row = entry.range.start.row;
    			
    			if(!result.rows.hasOwnProperty(row)){
                 result.rows[row] = {count: entry.count, text: "This block has been called " + entry.count + " times"};
    			}
                
                if(result.maxCount< entry.count){
                    result.maxCount = entry.count;
                }
            }
            
            return result;
	}
    
}

	
	
    
    //Esprima
    // done: prepare demo from http://esprima.org/demo/functiontrace.html into this one 
    // done: look the required statements in the tree
    // todo: instrument the log of issue 16 [pending to catch the expression statement parent so code can be appended]
    // todo: collect the stack trace [ populate tree with callstack sequences]
    var canTrace = true;
    window.onload = function () {
        'use strict';
            
        let editor = ace.edit("editor");
        let tooltip = document.getElementById('tooltip_0');
        
        if(tooltip === null){
        			tooltip = document.createElement('div');		
        			tooltip.setAttribute('id', 'tooltip_0'); 
        			tooltip.setAttribute('class', 'seecoderun_tooltip'); // and make sure myclass has some styles in css
        			document.body.appendChild(tooltip);
        }
        let gutterDecorationClassName = "seecoderun_gutter_decoration";
        var traceViewModel = new TraceViewModel(editor, tooltip, gutterDecorationClassName);  
            
        
        // update the status of the trace run
        let eventListener =function  (event){
            if(event.status === "Running"){
                document.getElementById('info').setAttribute('class', 'alert-box secondary');
                document.getElementById('info').innerHTML = event.description;
        		document.getElementById('stacktrace').innerHTML = 'Waiting...';        
            }else if(event.status === "Finished"){
                
                let trace = window.TRACE.getStackTrace();
                traceViewModel.onTraceChanged(trace);
              
                document.getElementById('info').setAttribute('class', 'alert-box secondary');
                document.getElementById('info').innerHTML = event.description;
         

        // 	    let variablesTrace = window.TRACE.getVariables();
        // 		document.getElementById('stacktrace').innerHTML =
        // 		    'VARIABLES :<br>'+ visualizeExecutionTrace(variablesTrace.variables) +
        // 		    '<br>VALUES:<br>' + visualizeExecutionTrace(variablesTrace.values);
        
        	    let expressionsTrace = window.TRACE.getExpressions();
        		document.getElementById('stacktrace').innerHTML =
        		    'EXPRESSIONS :<br>'+ visualizeExecutionTrace(expressionsTrace.timeline);
        	 
            }else if(event.status === "Error"){
                document.getElementById('info').innerHTML = event.description;
                document.getElementById('info').setAttribute('class', 'alert-box alert');
                document.getElementById('stacktrace').innerHTML = 'Waiting...';
            }else if(event.status === "Timeout"){
                document.getElementById('info').innerHTML = event.description;
                document.getElementById('info').setAttribute('class', 'alert-box alert');
                document.getElementById('stacktrace').innerHTML = 'Waiting...';
            }else if(event.status === "Busy"){
                document.getElementById('info').innerHTML = event.description;
                document.getElementById('info').setAttribute('class', 'alert-box alert');
                document.getElementById('stacktrace').innerHTML = 'Busy, please wait...';
            }
        };
        canTrace=true;
        window.CANTRACE =true;
    	
        document.getElementById('info').setAttribute('class', 'alert-box secondary');
        document.getElementById('info').innerHTML = 'Ready.';
        
    	var executionTrace = JSON.parse(localStorage.getItem('executionTrace'));
    	if(executionTrace){
    	    visualize(executionTrace.stackTrace);
    	}
    	
    	setTimeout(function(){  canTrace = true;}, 3000);
    	
    	var aceDocumentForEsprima = editor.getSession().getDocument(); // get the document for changes in its structure
    	aceDocumentForEsprima.on("change", function(e){
    	    var sourceCode = aceDocumentForEsprima.getValue(); // get the code to analyze

    	    var data = {functions: {main: {code : `function main(x){ var z = 7; for (var i = 0; i < z; i++) {var out = debuggerTest(x++, i);} return out;};`},
    	        debuggerTest: {code : `function debuggerTest(n){
                var N = n, data = []; while (N > 0) data.push(N--); return data;
            }`}
    	    }, stubs:{}};
    	    Debugger.init(data);
    	    console.log(JSON.stringify(Debugger.run("var y =7; main(y);")));
    	    console.log(JSON.stringify(Debugger.logs)+ "\n\n");
    	    console.log(JSON.stringify(data));
    	    console.log(JSON.stringify(Debugger.stubs));
    	        
    	    // API CALL
    	    if(canTrace){
    	    	//window.traceExecution(sourceCode, eventListener);
    	    	canTrace = false;
    	        setTimeout(function(){  canTrace = true;}, 3000);
    	        
    	    }
    
    	});

    
    };
    
    
    // example of how to use the trace resulting data structure
    function visualize(stackTrace){
        var i, entry, name, index;
        var stackText= "";
    	var repeat = 0;
    	var previousCall = "";
    	var previousIndex = -1;
        for (i = 0; i < stackTrace.length; i += 1) {
            entry = stackTrace[i];
            if(entry){
                name = entry.text;
        		index = entry.index;
        		 if(previousCall !== name){				 
        			 if(repeat > 0){
        				 stackText += previousIndex + " -- " + previousCall + "( + "+ repeat +" times) <br>";
        				 repeat = 0;
        			 }else{
        				 if(previousIndex > -1){
        					 stackText += previousIndex + " -- " + previousCall + "<br> ";
        				 }
        				 
        			 }
        			 previousCall = name;
        			 previousIndex = index;
        		 }else{
        			 repeat = repeat + 1; 
        		 }
            }
    		
        }
    	if(repeat > 0){
    		stackText +=  previousIndex + " -- " + previousCall + "( + "+ repeat +" times )";
    		repeat = 0;
    	}else{
    		if(previousIndex > -1){
    			stackText += previousIndex + " -- " + previousCall ;
    		}					 
    	}
    	
    	return stackText;  
    
    }
     // example of how to use the trace resulting data structure
    function visualizeExecutionTrace(executionTrace){
        var i, entry;
        var stackText= "";

        for (i = 0; i < executionTrace.length; i += 1) {
            entry = executionTrace[i];
            stackText += i + " -- " + JSON.stringify(entry) + "<br> ";
           
        }
       
    	
    	return stackText;  
    
    }
    
</script>
</body>
</html>